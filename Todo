=> Timeout in read operation
=> remove throw when binfing and create a sockets 
=> return 301 302


// void	Cgi::readaOutfile(std::string &path)
// {
// 	std::ifstream	in;
// 	std::string		header;
// 	std::string		buffer;
// 	size_t			found;	
// 	char 			buff[2048];
// 	int				b;

// 		// std::cout << "buffer === > " << buffer << "\n";
// 	std::cout << path << "\n";
// 	fd = open(path.c_str(), O_RDWR);
// 	b = read(fd, buff, sizeof(buff));
// 	buff[b] = '\0';
// 	close(fd);
// 	buffer = buff;
// 	found  = buffer.find("\r\n\r\n");
// 	if (found != std::string::npos)
// 		buffer = buffer.substr(0, found);
// 	else
// 	{
// 		buffer = "200 ok";
// 	 	response.setStatusCodeMsg(buffer);
	
// 		return ;
// 	}
// 	found = buffer.find("status: ");
// 	if (found != std::string::npos)
// 		buffer = buffer.substr(found);
// 	else
// 	{
// 		buffer = "200 ok";
// 		response.setStatusCodeMsg(buffer);
// 		return ;
// 	}
	
// 	found = buffer.find_first_of(" ");
// 	if (found != std::string::npos)
// 		buffer = buffer.substr(found, header.find_first_of("\n"));
//  	response.setStatusCodeMsg(buffer);
// }

// void	Cgi::waitCgi(Stage &stage, int &pid)
// {
// 	int		status;
// 	int		exitStatus;

// 	waitpid(pid, &status, WNOHANG);
// 	if (WIFEXITED(status))
// 	{
// 		exitStatus = WEXITSTATUS(status);
// 		if (exitStatus == 500)
// 		{
// 			stage = RESHEADER;
// 			response.throwNewPath("500 Internal Server Error", "500");
// 		}
// 		// readaOutfile(path);
// 		pid = -2;
// 		std::cout << "hadi\\\\\n";
// 		throw(path);
// 	}
// }